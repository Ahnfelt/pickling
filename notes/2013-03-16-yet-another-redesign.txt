=========== PICKLING ===========

trait Pickler[T] {
  type PickleBuilderType <: PickleBuilder
  def pickle(picklee: Any, builder: PickleBuilderType): PickleBuilderType
}

trait PickleBuilder {
  type PickleType <: Pickle
  def startObject(tpe: Type, picklee: Any): this.type
  def putField(name: String, value: => this.type): this.type
  def finishObject(): this.type
  def toPickle(): PickleType
}

1) foo.pickle

is expanded to

{
  val b = implicitly[PickleFormat].createBuilder
  typeOf(foo) match { // dispatch can be optimized away if foo is final
    case tpe if tpe =:= typeOf[C1] => genPickler[C1].pickle(foo, b)
    ...
    case tpe if tpe =:= typeOf[CN] => genPickler[CN].pickle(foo, b)
    case _ => genPickler(currentMirror, tpe).pickle(foo, b)
  }
  b.toPickle()
}

2) genPickler[T] expands into a top-level class, which extends Pickler[T] and has an autogenerated body of pickle

2a) for primitive types:

class IntJSONPickler extends Pickler[Int] { // note that we no longer depend on pickle format!
  type PickleBuilderType = JSONPickleBuilder
  def pickle(picklee: Any, builder: JSONPickleBuilder): JSONPickleBuilder = {
    // I) don't have the primitive dilemma => builder decides what's primitive and what's not
    // II) builder methods can be inlined if declared as macros => we need precise PickleBuilderType to enable such an optimization
    // III) we might even not have to construct instances of Types at runtime if startObject is a macro
    builder.startObject(typeOf[Int], picklee).finishObject()
  }
}

2b) for nested types:

case class Person(name: String, pet: Pet)

class PersonJSONPickler extends Pickler[Int] {
  implicit val pickleFormat = new JSONPickleFormat()
  type PickleBuilderType = JSONPickleBuilder
  def pickle(pickleeRaw: Any, builder: JSONPickleBuilder): JSONPickleBuilder = {
    val picklee = pickleeRaw.asInstanceOf[Person]
    builder.startObject(typeOf[Person], picklee)
           .putField("name", {
      val name = picklee.name
      name.pickler.pickle(name, builder) // the .pickler macro does the same that the .pickle macro does, but omits the last "toPickle" line
                                   // NOTE: if we go for introduceTopLevel, then dispatch code generated here won't take into account the scope of the callsite
    }) // again, no special treatment for primitives
    builder.finishObject()
  }
}
