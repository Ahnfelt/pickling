=========== PICKLING ===========

trait Pickler[T] {
  type PickleBuilderType <: PickleBuilder
  def pickle(picklee: Any, builder: PickleBuilderType): PickleBuilderType
}

trait PickleBuilder {
  type PickleType <: Pickle
  def startObject(tpe: Type, picklee: Any): this.type
  def putField(name: String, value: this.type => this.type): this.type
  def finishObject(): Unit
  def toPickle(): PickleType
}

1) foo.pickle

is expanded to

{
  val b = implicitly[PickleFormat].createBuilder
  typeOf(foo) match { // dispatch can be optimized away if foo is final
                      // null check can be optimized away if foo is a value class
    case null => genPickler[Null].pickle(foo, b)
    case tpe if tpe =:= typeOf[C1] => genPickler[C1].pickle(foo, b)
    ...
    case tpe if tpe =:= typeOf[CN] => genPickler[CN].pickle(foo, b)
    case tpe => genPickler(currentMirror, tpe).pickle(foo, b)
  }
  b.toPickle()
}

2) genPickler[T] expands into a top-level class, which extends Pickler[T] and has an autogenerated body of the pickle method

2a) for primitive types:

class IntJSONPickler extends Pickler[Int] { // note that we no longer depend on pickle format!
                                            // though we still need to specialize picklers to
                                            // precise types of format-related things because of macros
  type PickleBuilderType = JSONPickleBuilder
  def pickle(picklee: Any, builder: JSONPickleBuilder): JSONPickleBuilder = {
    // I) don't have the primitive dilemma => builder decides what's primitive and what's not
    // II) builder methods can be inlined if declared as macros => we need precise PickleBuilderType to enable such an optimization
    // III) we might even not have to construct instances of Types at runtime if startObject is a macro
    builder.startObject(typeOf[Int], picklee).finishObject()
  }
}

2b) for nested types:

case class Person(name: String, pet: Pet)

class PersonJSONPickler extends Pickler[Int] {
  implicit val pickleFormat = new JSONPickleFormat()
  type PickleBuilderType = JSONPickleBuilder
  def pickle(pickleeRaw: Any, builder: JSONPickleBuilder): JSONPickleBuilder = {
    val picklee = pickleeRaw.asInstanceOf[Person]
    builder.startObject(typeOf[Person], picklee)
           .putField("name", picklee.name.picklePart) // again, no special treatment for primitives
                                                      // .picklePart does the same as .pickle, but without the final call to .toPickle
                                                      // we could even have a macro, which lets people to write .pickle and then converts it to .picklePart
                                                      // NOTE: if we go for introduceTopLevel, then the dispatch code generated here
                                                      // won't take into account the scope of the callsite

           .finishObject()
  }
}
